# 第6章 软件系统维护与支持

## 6.1 维护内容

### 6.1.1 日常维护

日常维护是保证智能配餐推荐系统持续稳定运行的关键。通过定期的监控、检查和维护操作，可以及时发现和解决潜在问题，确保系统为用户提供可靠的服务。

#### 1. 系统监控

系统监控是日常维护的核心工作，需要持续关注系统的运行状态和性能指标。

##### 1.1 实时性能指标监控

**监控指标体系**：

```
┌─────────────────────────────────────────────────────────────┐
│                   系统监控指标体系                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【CPU监控】                                                 │
│  ├─ CPU使用率                目标 < 70%  告警 > 85%         │
│  ├─ CPU温度                  目标 < 60°C 告警 > 80°C        │
│  ├─ 线程数                   正常范围内                     │
│  └─ 进程优先级               正常                           │
│                                                             │
│  【内存监控】                                                 │
│  ├─ 内存使用率               目标 < 60%  告警 > 80%         │
│  ├─ 可用内存                 > 1GB                          │
│  ├─ 内存泄漏检测             无持续增长趋势                 │
│  └─ 虚拟内存使用             < 50%                          │
│                                                             │
│  【磁盘监控】                                                 │
│  ├─ 磁盘使用率               目标 < 70%  告警 > 85%         │
│  ├─ 可用空间                 > 5GB                          │
│  ├─ 磁盘I/O                  读写速度正常                   │
│  └─ SMART状态                健康                           │
│                                                             │
│  【网络监控】                                                 │
│  ├─ 网络连接数               < 100 (并发)                   │
│  ├─ 响应时间                 < 1秒                          │
│  ├─ 数据包丢失率             < 0.1%                         │
│  └─ 带宽使用                 合理范围                       │
│                                                             │
│  【应用监控】                                                 │
│  ├─ 进程状态                 运行中                         │
│  ├─ 端口监听                 8000端口正常                   │
│  ├─ API响应时间              < 500ms                        │
│  └─ 错误率                   < 1%                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Windows系统监控脚本**：

```powershell
# 系统监控脚本: monitor_system.ps1
# 用途: 实时监控系统关键指标

param(
    [int]$Interval = 60,  # 监控间隔（秒）
    [int]$Duration = 0    # 运行时长（0=持续运行）
)

function Get-SystemMetrics {
    $metrics = @{}
    
    # CPU监控
    $cpu = Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue
    $metrics.CPUUsage = [math]::Round($cpu.CounterSamples[0].CookedValue, 2)
    
    # 内存监控
    $os = Get-CimInstance Win32_OperatingSystem
    $totalMem = [math]::Round($os.TotalVisibleMemorySize / 1MB, 2)
    $freeMem = [math]::Round($os.FreePhysicalMemory / 1MB, 2)
    $usedMem = $totalMem - $freeMem
    $metrics.MemoryUsage = [math]::Round(($usedMem / $totalMem) * 100, 2)
    $metrics.MemoryFree = $freeMem
    
    # 磁盘监控
    $disk = Get-PSDrive C | Select-Object Used, Free
    $totalDisk = ($disk.Used + $disk.Free) / 1GB
    $metrics.DiskUsage = [math]::Round(($disk.Used / 1GB / $totalDisk) * 100, 2)
    $metrics.DiskFree = [math]::Round($disk.Free / 1GB, 2)
    
    # 进程监控
    $process = Get-Process -Name "MealRecommendationSystem" -ErrorAction SilentlyContinue
    if ($process) {
        $metrics.ProcessRunning = $true
        $metrics.ProcessMemory = [math]::Round($process.WorkingSet64 / 1MB, 2)
        $metrics.ProcessCPU = [math]::Round($process.CPU, 2)
        $metrics.ProcessThreads = $process.Threads.Count
    } else {
        $metrics.ProcessRunning = $false
    }
    
    # 网络监控
    try {
        $response = Invoke-WebRequest -Uri "http://localhost:8000" -UseBasicParsing -TimeoutSec 5
        $metrics.ServiceReachable = $true
        $metrics.HTTPStatus = $response.StatusCode
    } catch {
        $metrics.ServiceReachable = $false
        $metrics.HTTPStatus = 0
    }
    
    return $metrics
}

function Show-Metrics {
    param($metrics, $timestamp)
    
    Clear-Host
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host "   智能配餐推荐系统 - 系统监控" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host "监控时间: $timestamp" -ForegroundColor Gray
    Write-Host ""
    
    # CPU状态
    Write-Host "【CPU状态】" -ForegroundColor Yellow
    $cpuColor = if ($metrics.CPUUsage -lt 70) { "Green" } elseif ($metrics.CPUUsage -lt 85) { "Yellow" } else { "Red" }
    Write-Host "  使用率: $($metrics.CPUUsage)%" -ForegroundColor $cpuColor
    Write-Host ""
    
    # 内存状态
    Write-Host "【内存状态】" -ForegroundColor Yellow
    $memColor = if ($metrics.MemoryUsage -lt 60) { "Green" } elseif ($metrics.MemoryUsage -lt 80) { "Yellow" } else { "Red" }
    Write-Host "  使用率: $($metrics.MemoryUsage)%" -ForegroundColor $memColor
    Write-Host "  可用内存: $($metrics.MemoryFree) GB" -ForegroundColor Gray
    Write-Host ""
    
    # 磁盘状态
    Write-Host "【磁盘状态】" -ForegroundColor Yellow
    $diskColor = if ($metrics.DiskUsage -lt 70) { "Green" } elseif ($metrics.DiskUsage -lt 85) { "Yellow" } else { "Red" }
    Write-Host "  使用率: $($metrics.DiskUsage)%" -ForegroundColor $diskColor
    Write-Host "  可用空间: $($metrics.DiskFree) GB" -ForegroundColor Gray
    Write-Host ""
    
    # 应用状态
    Write-Host "【应用状态】" -ForegroundColor Yellow
    if ($metrics.ProcessRunning) {
        Write-Host "  进程状态: 运行中" -ForegroundColor Green
        Write-Host "  进程内存: $($metrics.ProcessMemory) MB" -ForegroundColor Gray
        Write-Host "  线程数: $($metrics.ProcessThreads)" -ForegroundColor Gray
    } else {
        Write-Host "  进程状态: 未运行" -ForegroundColor Red
    }
    Write-Host ""
    
    # 服务状态
    Write-Host "【服务状态】" -ForegroundColor Yellow
    if ($metrics.ServiceReachable) {
        Write-Host "  HTTP服务: 正常 (状态码: $($metrics.HTTPStatus))" -ForegroundColor Green
        Write-Host "  访问地址: http://localhost:8000" -ForegroundColor Gray
    } else {
        Write-Host "  HTTP服务: 异常" -ForegroundColor Red
    }
    Write-Host ""
    
    # 告警信息
    $hasWarning = $false
    Write-Host "【告警信息】" -ForegroundColor Yellow
    if ($metrics.CPUUsage -gt 85) {
        Write-Host "  ⚠ CPU使用率过高: $($metrics.CPUUsage)%" -ForegroundColor Red
        $hasWarning = $true
    }
    if ($metrics.MemoryUsage -gt 80) {
        Write-Host "  ⚠ 内存使用率过高: $($metrics.MemoryUsage)%" -ForegroundColor Red
        $hasWarning = $true
    }
    if ($metrics.DiskUsage -gt 85) {
        Write-Host "  ⚠ 磁盘使用率过高: $($metrics.DiskUsage)%" -ForegroundColor Red
        $hasWarning = $true
    }
    if (-not $metrics.ProcessRunning) {
        Write-Host "  ⚠ 应用进程未运行" -ForegroundColor Red
        $hasWarning = $true
    }
    if (-not $metrics.ServiceReachable) {
        Write-Host "  ⚠ HTTP服务无法访问" -ForegroundColor Red
        $hasWarning = $true
    }
    if (-not $hasWarning) {
        Write-Host "  ✓ 系统运行正常，无告警" -ForegroundColor Green
    }
    
    Write-Host ""
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host "下次刷新: $Interval 秒后" -ForegroundColor Gray
    Write-Host "按 Ctrl+C 退出监控" -ForegroundColor Gray
}

function Write-MonitorLog {
    param($metrics, $timestamp)
    
    $logDir = "C:\MealRecommendationSystem\logs"
    if (-not (Test-Path $logDir)) {
        New-Item -ItemType Directory -Path $logDir | Out-Null
    }
    
    $logFile = Join-Path $logDir "monitor_$(Get-Date -Format 'yyyyMMdd').log"
    $logEntry = "$timestamp | CPU: $($metrics.CPUUsage)% | Memory: $($metrics.MemoryUsage)% | Disk: $($metrics.DiskUsage)% | Process: $($metrics.ProcessRunning) | HTTP: $($metrics.ServiceReachable)"
    Add-Content -Path $logFile -Value $logEntry
}

# 主循环
Write-Host "启动系统监控..." -ForegroundColor Green
Write-Host "监控间隔: $Interval 秒" -ForegroundColor Gray
Write-Host ""

$startTime = Get-Date
$iteration = 0

try {
    while ($true) {
        $iteration++
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        
        # 获取监控数据
        $metrics = Get-SystemMetrics
        
        # 显示监控信息
        Show-Metrics -metrics $metrics -timestamp $timestamp
        
        # 写入日志
        Write-MonitorLog -metrics $metrics -timestamp $timestamp
        
        # 检查运行时长
        if ($Duration -gt 0) {
            $elapsed = (Get-Date) - $startTime
            if ($elapsed.TotalSeconds -ge $Duration) {
                Write-Host ""
                Write-Host "监控时长已达到 $Duration 秒，退出监控" -ForegroundColor Yellow
                break
            }
        }
        
        # 等待下一次监控
        Start-Sleep -Seconds $Interval
    }
} catch {
    Write-Host ""
    Write-Host "监控已停止" -ForegroundColor Yellow
}

Write-Host ""
Write-Host "共执行 $iteration 次监控" -ForegroundColor Gray
Write-Host "日志已保存到: C:\MealRecommendationSystem\logs\" -ForegroundColor Gray
```

**使用方法**：
```powershell
# 持续监控（每60秒刷新一次）
.\monitor_system.ps1

# 自定义监控间隔（每30秒刷新一次）
.\monitor_system.ps1 -Interval 30

# 限时监控（运行1小时）
.\monitor_system.ps1 -Interval 60 -Duration 3600
```

##### 1.2 日志监控

**日志文件说明**：

```
日志目录结构:
C:\MealRecommendationSystem\logs\
├── server_20240120.log        # 服务器运行日志
├── error_20240120.log          # 错误日志
├── access_20240120.log         # 访问日志
├── monitor_20240120.log        # 监控日志
└── audit_20240120.log          # 审计日志（可选）

日志级别:
  ERROR   - 错误信息，需要立即处理
  WARN    - 警告信息，需要关注
  INFO    - 一般信息
  DEBUG   - 调试信息
```

**日志分析脚本**：

```powershell
# 日志分析脚本: analyze_logs.ps1

param(
    [string]$LogPath = "C:\MealRecommendationSystem\logs",
    [string]$Date = (Get-Date -Format "yyyyMMdd")
)

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "日志分析工具" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "分析日期: $Date" -ForegroundColor Gray
Write-Host ""

# 查找日志文件
$logFiles = Get-ChildItem -Path $LogPath -Filter "*$Date*.log" -ErrorAction SilentlyContinue

if ($logFiles.Count -eq 0) {
    Write-Host "未找到日期为 $Date 的日志文件" -ForegroundColor Yellow
    exit
}

Write-Host "找到 $($logFiles.Count) 个日志文件:" -ForegroundColor Green
$logFiles | ForEach-Object { Write-Host "  - $($_.Name)" -ForegroundColor Gray }
Write-Host ""

# 分析错误日志
$errorLog = $logFiles | Where-Object { $_.Name -like "*error*" }
if ($errorLog) {
    Write-Host "【错误日志分析】" -ForegroundColor Yellow
    $errorContent = Get-Content $errorLog.FullName -ErrorAction SilentlyContinue
    if ($errorContent) {
        $errorCount = $errorContent.Count
        Write-Host "  错误记录数: $errorCount" -ForegroundColor $(if ($errorCount -eq 0) { "Green" } else { "Red" })
        
        if ($errorCount -gt 0) {
            Write-Host ""
            Write-Host "  最近的错误:" -ForegroundColor Red
            $errorContent | Select-Object -Last 5 | ForEach-Object {
                Write-Host "    $_" -ForegroundColor Gray
            }
        }
    }
    Write-Host ""
}

# 分析访问日志
$accessLog = $logFiles | Where-Object { $_.Name -like "*access*" }
if ($accessLog) {
    Write-Host "【访问日志分析】" -ForegroundColor Yellow
    $accessContent = Get-Content $accessLog.FullName -ErrorAction SilentlyContinue
    if ($accessContent) {
        $totalRequests = $accessContent.Count
        Write-Host "  总请求数: $totalRequests" -ForegroundColor Green
        
        # 统计请求类型
        $getRequests = ($accessContent | Select-String "GET").Count
        $postRequests = ($accessContent | Select-String "POST").Count
        Write-Host "  GET请求: $getRequests" -ForegroundColor Gray
        Write-Host "  POST请求: $postRequests" -ForegroundColor Gray
        
        # 统计状态码
        $status200 = ($accessContent | Select-String " 200 ").Count
        $status404 = ($accessContent | Select-String " 404 ").Count
        $status500 = ($accessContent | Select-String " 500 ").Count
        Write-Host "  200 (成功): $status200" -ForegroundColor Green
        if ($status404 -gt 0) {
            Write-Host "  404 (未找到): $status404" -ForegroundColor Yellow
        }
        if ($status500 -gt 0) {
            Write-Host "  500 (服务器错误): $status500" -ForegroundColor Red
        }
    }
    Write-Host ""
}

# 分析监控日志
$monitorLog = $logFiles | Where-Object { $_.Name -like "*monitor*" }
if ($monitorLog) {
    Write-Host "【监控日志分析】" -ForegroundColor Yellow
    $monitorContent = Get-Content $monitorLog.FullName -ErrorAction SilentlyContinue
    if ($monitorContent) {
        Write-Host "  监控记录数: $($monitorContent.Count)" -ForegroundColor Green
        
        # 分析CPU使用率
        $cpuValues = $monitorContent | ForEach-Object {
            if ($_ -match "CPU: ([\d.]+)%") {
                [double]$matches[1]
            }
        }
        if ($cpuValues) {
            $avgCPU = ($cpuValues | Measure-Object -Average).Average
            $maxCPU = ($cpuValues | Measure-Object -Maximum).Maximum
            Write-Host "  平均CPU: $([math]::Round($avgCPU, 2))%" -ForegroundColor Gray
            Write-Host "  最高CPU: $([math]::Round($maxCPU, 2))%" -ForegroundColor $(if ($maxCPU -gt 85) { "Red" } else { "Gray" })
        }
        
        # 分析内存使用率
        $memValues = $monitorContent | ForEach-Object {
            if ($_ -match "Memory: ([\d.]+)%") {
                [double]$matches[1]
            }
        }
        if ($memValues) {
            $avgMem = ($memValues | Measure-Object -Average).Average
            $maxMem = ($memValues | Measure-Object -Maximum).Maximum
            Write-Host "  平均内存: $([math]::Round($avgMem, 2))%" -ForegroundColor Gray
            Write-Host "  最高内存: $([math]::Round($maxMem, 2))%" -ForegroundColor $(if ($maxMem -gt 80) { "Red" } else { "Gray" })
        }
    }
    Write-Host ""
}

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "分析完成" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
```

#### 2. 数据备份

数据备份是系统维护的重要组成部分，确保在发生数据丢失或损坏时能够快速恢复。

##### 2.1 备份策略

**备份策略表**：

| 备份类型 | 频率 | 保留期限 | 备份内容 | 自动化 |
|---------|------|---------|---------|--------|
| **完全备份** | 每周 | 4周 | 所有数据文件 | 是 |
| **增量备份** | 每天 | 7天 | 变更的文件 | 是 |
| **实时备份** | 实时 | 24小时 | 关键操作 | 可选 |
| **归档备份** | 每月 | 永久 | 月度数据快照 | 是 |
| **手动备份** | 按需 | 自定义 | 指定文件 | 否 |

**备份内容清单**：

```
必须备份的内容:
  ✓ data/users.txt           - 用户数据（最重要）
  ✓ data/meals.txt           - 餐单历史数据（重要）
  ✓ data/foods.txt           - 食物库数据（可恢复）

可选备份的内容:
  • logs/                    - 日志文件（保留最近30天）
  • config/                  - 配置文件（如果有）

不需要备份的内容:
  ✗ bin/                     - 可执行文件（可重新编译）
  ✗ www/                     - 前端文件（版本控制）
  ✗ backup/                  - 备份目录本身
```

##### 2.2 自动备份脚本

**每日自动备份脚本**：

```batch
REM 每日自动备份脚本: daily_backup.bat
REM 建议通过任务计划程序每天凌晨2点运行

@echo off
setlocal enabledelayedexpansion

REM ========================================
REM 配置参数
REM ========================================
set SOURCE_DIR=C:\MealRecommendationSystem\data
set BACKUP_ROOT=C:\MealRecommendationSystem\backup
set RETENTION_DAYS=7

REM 生成备份目录名（带时间戳）
set BACKUP_DATE=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%
set BACKUP_DATE=!BACKUP_DATE: =0!
set BACKUP_DIR=%BACKUP_ROOT%\daily\backup_!BACKUP_DATE!

REM 日志文件
set LOG_FILE=%BACKUP_ROOT%\backup.log

echo ======================================== >> "%LOG_FILE%"
echo 备份开始时间: %date% %time% >> "%LOG_FILE%"
echo ======================================== >> "%LOG_FILE%"

REM ========================================
REM 步骤1: 检查源目录
REM ========================================
if not exist "%SOURCE_DIR%" (
    echo [ERROR] 源目录不存在: %SOURCE_DIR% >> "%LOG_FILE%"
    exit /b 1
)
echo [INFO] 源目录: %SOURCE_DIR% >> "%LOG_FILE%"

REM ========================================
REM 步骤2: 创建备份目录
REM ========================================
if not exist "%BACKUP_ROOT%\daily" mkdir "%BACKUP_ROOT%\daily"
mkdir "%BACKUP_DIR%"
echo [INFO] 备份目录: %BACKUP_DIR% >> "%LOG_FILE%"

REM ========================================
REM 步骤3: 复制数据文件
REM ========================================
echo [INFO] 开始复制数据文件... >> "%LOG_FILE%"
xcopy /E /I /Y "%SOURCE_DIR%\*" "%BACKUP_DIR%\" >> "%LOG_FILE%" 2>&1

if %ERRORLEVEL% EQU 0 (
    echo [SUCCESS] 数据备份成功 >> "%LOG_FILE%"
    
    REM 统计备份文件信息
    for %%F in ("%BACKUP_DIR%\*") do (
        echo [INFO] 备份文件: %%~nxF (%%~zF 字节) >> "%LOG_FILE%"
    )
) else (
    echo [ERROR] 数据备份失败 >> "%LOG_FILE%"
    exit /b 1
)

REM ========================================
REM 步骤4: 压缩备份（可选）
REM ========================================
if exist "C:\Program Files\7-Zip\7z.exe" (
    echo [INFO] 压缩备份文件... >> "%LOG_FILE%"
    "C:\Program Files\7-Zip\7z.exe" a -tzip "%BACKUP_DIR%.zip" "%BACKUP_DIR%\*" >> "%LOG_FILE%" 2>&1
    
    if %ERRORLEVEL% EQU 0 (
        echo [SUCCESS] 备份压缩成功 >> "%LOG_FILE%"
        REM 删除未压缩的备份目录
        rd /s /q "%BACKUP_DIR%"
    )
)

REM ========================================
REM 步骤5: 清理过期备份
REM ========================================
echo [INFO] 清理过期备份（保留 %RETENTION_DAYS% 天）... >> "%LOG_FILE%"
forfiles /P "%BACKUP_ROOT%\daily" /D -%RETENTION_DAYS% /C "cmd /c echo [INFO] 删除过期备份: @file && rd /s /q @path || del /q @path" >> "%LOG_FILE%" 2>&1

REM ========================================
REM 步骤6: 验证备份完整性
REM ========================================
echo [INFO] 验证备份完整性... >> "%LOG_FILE%"
set BACKUP_OK=1

if exist "%BACKUP_DIR%.zip" (
    set BACKUP_PATH=%BACKUP_DIR%.zip
) else (
    set BACKUP_PATH=%BACKUP_DIR%
)

if not exist "%BACKUP_PATH%\users.txt" (
    if not exist "%BACKUP_PATH%" (
        echo [ERROR] users.txt 备份缺失 >> "%LOG_FILE%"
        set BACKUP_OK=0
    )
)

if %BACKUP_OK% EQU 1 (
    echo [SUCCESS] 备份完整性验证通过 >> "%LOG_FILE%"
) else (
    echo [ERROR] 备份完整性验证失败 >> "%LOG_FILE%"
)

echo ======================================== >> "%LOG_FILE%"
echo 备份结束时间: %date% %time% >> "%LOG_FILE%"
echo ======================================== >> "%LOG_FILE%"
echo. >> "%LOG_FILE%"

exit /b 0
```

**PowerShell版本（功能更强大）**：

```powershell
# 高级备份脚本: advanced_backup.ps1

param(
    [string]$SourceDir = "C:\MealRecommendationSystem\data",
    [string]$BackupRoot = "C:\MealRecommendationSystem\backup",
    [int]$RetentionDays = 7,
    [switch]$Compress = $true,
    [switch]$EmailNotification = $false
)

function Write-BackupLog {
    param([string]$Message, [string]$Level = "INFO")
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    $logFile = Join-Path $BackupRoot "backup.log"
    
    Add-Content -Path $logFile -Value $logEntry
    
    $color = switch ($Level) {
        "ERROR" { "Red" }
        "WARN" { "Yellow" }
        "SUCCESS" { "Green" }
        default { "White" }
    }
    Write-Host $logEntry -ForegroundColor $color
}

function New-Backup {
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupDir = Join-Path $BackupRoot "daily\backup_$timestamp"
    
    Write-BackupLog "========================================" "INFO"
    Write-BackupLog "开始备份操作" "INFO"
    Write-BackupLog "========================================" "INFO"
    
    # 检查源目录
    if (-not (Test-Path $SourceDir)) {
        Write-BackupLog "源目录不存在: $SourceDir" "ERROR"
        return $false
    }
    
    # 创建备份目录
    $dailyBackupDir = Join-Path $BackupRoot "daily"
    if (-not (Test-Path $dailyBackupDir)) {
        New-Item -ItemType Directory -Path $dailyBackupDir | Out-Null
    }
    New-Item -ItemType Directory -Path $backupDir | Out-Null
    Write-BackupLog "备份目录: $backupDir" "INFO"
    
    # 复制文件
    try {
        Write-BackupLog "复制数据文件..." "INFO"
        Copy-Item -Path "$SourceDir\*" -Destination $backupDir -Recurse -Force
        
        # 统计备份信息
        $backupFiles = Get-ChildItem -Path $backupDir -File
        $totalSize = ($backupFiles | Measure-Object -Property Length -Sum).Sum / 1MB
        Write-BackupLog "备份文件数: $($backupFiles.Count)" "INFO"
        Write-BackupLog "备份大小: $([math]::Round($totalSize, 2)) MB" "INFO"
        
        foreach ($file in $backupFiles) {
            Write-BackupLog "  - $($file.Name) ($([math]::Round($file.Length / 1KB, 2)) KB)" "INFO"
        }
        
    } catch {
        Write-BackupLog "文件复制失败: $($_.Exception.Message)" "ERROR"
        return $false
    }
    
    # 压缩备份
    if ($Compress) {
        try {
            Write-BackupLog "压缩备份文件..." "INFO"
            $zipFile = "$backupDir.zip"
            Compress-Archive -Path "$backupDir\*" -DestinationPath $zipFile -Force
            
            $zipSize = (Get-Item $zipFile).Length / 1MB
            Write-BackupLog "压缩文件: $zipFile" "SUCCESS"
            Write-BackupLog "压缩后大小: $([math]::Round($zipSize, 2)) MB" "INFO"
            
            # 删除未压缩的目录
            Remove-Item -Path $backupDir -Recurse -Force
            Write-BackupLog "已删除未压缩的备份目录" "INFO"
            
        } catch {
            Write-BackupLog "压缩失败: $($_.Exception.Message)" "WARN"
        }
    }
    
    Write-BackupLog "备份完成" "SUCCESS"
    return $true
}

function Remove-OldBackups {
    Write-BackupLog "清理过期备份（保留 $RetentionDays 天）..." "INFO"
    
    $cutoffDate = (Get-Date).AddDays(-$RetentionDays)
    $dailyBackupDir = Join-Path $BackupRoot "daily"
    
    if (Test-Path $dailyBackupDir) {
        $oldBackups = Get-ChildItem -Path $dailyBackupDir | Where-Object {
            $_.LastWriteTime -lt $cutoffDate
        }
        
        foreach ($backup in $oldBackups) {
            try {
                Remove-Item -Path $backup.FullName -Recurse -Force
                Write-BackupLog "已删除过期备份: $($backup.Name)" "INFO"
            } catch {
                Write-BackupLog "删除失败: $($backup.Name)" "WARN"
            }
        }
        
        if ($oldBackups.Count -eq 0) {
            Write-BackupLog "没有需要清理的过期备份" "INFO"
        } else {
            Write-BackupLog "共清理 $($oldBackups.Count) 个过期备份" "SUCCESS"
        }
    }
}

function Test-BackupIntegrity {
    Write-BackupLog "验证备份完整性..." "INFO"
    
    $dailyBackupDir = Join-Path $BackupRoot "daily"
    $latestBackup = Get-ChildItem -Path $dailyBackupDir | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    
    if (-not $latestBackup) {
        Write-BackupLog "未找到备份文件" "ERROR"
        return $false
    }
    
    $requiredFiles = @("users.txt", "foods.txt", "meals.txt")
    $allFilesPresent = $true
    
    if ($latestBackup.Extension -eq ".zip") {
        # 检查ZIP文件中的内容
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        $zip = [System.IO.Compression.ZipFile]::OpenRead($latestBackup.FullName)
        
        foreach ($file in $requiredFiles) {
            $entry = $zip.Entries | Where-Object { $_.Name -eq $file }
            if (-not $entry) {
                Write-BackupLog "缺失文件: $file" "ERROR"
                $allFilesPresent = $false
            }
        }
        
        $zip.Dispose()
    } else {
        # 检查目录中的文件
        foreach ($file in $requiredFiles) {
            $filePath = Join-Path $latestBackup.FullName $file
            if (-not (Test-Path $filePath)) {
                Write-BackupLog "缺失文件: $file" "ERROR"
                $allFilesPresent = $false
            }
        }
    }
    
    if ($allFilesPresent) {
        Write-BackupLog "备份完整性验证通过" "SUCCESS"
        return $true
    } else {
        Write-BackupLog "备份完整性验证失败" "ERROR"
        return $false
    }
}

function Send-EmailNotification {
    param([bool]$Success)
    
    # 邮件通知功能（需要配置SMTP服务器）
    # 这里提供一个框架，实际使用需要配置
    
    if (-not $EmailNotification) {
        return
    }
    
    $subject = if ($Success) {
        "智能配餐系统 - 备份成功"
    } else {
        "智能配餐系统 - 备份失败"
    }
    
    $body = "备份时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`n"
    $body += "备份状态: $(if ($Success) { '成功' } else { '失败' })`n"
    $body += "`n详细日志请查看服务器上的备份日志文件。"
    
    Write-BackupLog "发送邮件通知..." "INFO"
    
    # TODO: 实际的邮件发送代码
    # Send-MailMessage -To "admin@example.com" -From "backup@example.com" -Subject $subject -Body $body -SmtpServer "smtp.example.com"
}

# 主执行流程
try {
    $success = New-Backup
    
    if ($success) {
        Remove-OldBackups
        $integrity = Test-BackupIntegrity
        
        if (-not $integrity) {
            $success = $false
        }
    }
    
    Send-EmailNotification -Success $success
    
    Write-BackupLog "========================================" "INFO"
    Write-BackupLog "备份流程结束" "INFO"
    Write-BackupLog "========================================" "INFO"
    
    exit $(if ($success) { 0 } else { 1 })
    
} catch {
    Write-BackupLog "备份过程中发生异常: $($_.Exception.Message)" "ERROR"
    Send-EmailNotification -Success $false
    exit 1
}
```

##### 2.3 配置自动备份任务

**使用Windows任务计划程序**：

```powershell
# 创建自动备份任务: create_backup_task.ps1

# 任务配置
$taskName = "智能配餐系统-每日备份"
$scriptPath = "C:\MealRecommendationSystem\scripts\advanced_backup.ps1"
$triggerTime = "02:00"  # 每天凌晨2点

# 删除旧任务（如果存在）
$existingTask = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
if ($existingTask) {
    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false
    Write-Host "已删除旧的计划任务" -ForegroundColor Yellow
}

# 创建触发器（每天凌晨2点）
$trigger = New-ScheduledTaskTrigger -Daily -At $triggerTime

# 创建操作
$action = New-ScheduledTaskAction -Execute "PowerShell.exe" `
    -Argument "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" -Compress"

# 创建主体（以SYSTEM身份运行，最高权限）
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

# 创建设置
$settings = New-ScheduledTaskSettingsSet `
    -AllowStartIfOnBatteries `
    -DontStopIfGoingOnBatteries `
    -StartWhenAvailable `
    -RunOnlyIfNetworkAvailable:$false

# 注册任务
Register-ScheduledTask -TaskName $taskName `
    -Trigger $trigger `
    -Action $action `
    -Principal $principal `
    -Settings $settings `
    -Description "智能配餐推荐系统的每日自动备份任务"

Write-Host "✓ 自动备份任务创建成功" -ForegroundColor Green
Write-Host "任务名称: $taskName" -ForegroundColor Gray
Write-Host "执行时间: 每天 $triggerTime" -ForegroundColor Gray
Write-Host "脚本路径: $scriptPath" -ForegroundColor Gray
Write-Host ""
Write-Host "可以通过以下命令查看任务:" -ForegroundColor Yellow
Write-Host "  Get-ScheduledTask -TaskName '$taskName'" -ForegroundColor Cyan
Write-Host ""
Write-Host "可以通过以下命令手动运行:" -ForegroundColor Yellow
Write-Host "  Start-ScheduledTask -TaskName '$taskName'" -ForegroundColor Cyan
```

#### 3. 安全更新

保持系统和依赖组件的安全更新是防范安全漏洞的重要措施。

##### 3.1 系统更新检查

**Windows更新检查脚本**：

```powershell
# 系统更新检查: check_updates.ps1

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "系统安全更新检查" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""

# 1. 检查Windows更新
Write-Host "[1/4] 检查Windows更新..." -ForegroundColor Yellow
try {
    $updateSession = New-Object -ComObject Microsoft.Update.Session
    $updateSearcher = $updateSession.CreateUpdateSearcher()
    $searchResult = $updateSearcher.Search("IsInstalled=0 and Type='Software'")
    
    if ($searchResult.Updates.Count -eq 0) {
        Write-Host "  ✓ Windows系统已是最新版本" -ForegroundColor Green
    } else {
        Write-Host "  ⚠ 发现 $($searchResult.Updates.Count) 个待安装更新:" -ForegroundColor Yellow
        $searchResult.Updates | ForEach-Object {
            Write-Host "    - $($_.Title)" -ForegroundColor Gray
        }
        Write-Host ""
        Write-Host "  建议: 运行Windows更新安装这些更新" -ForegroundColor Yellow
    }
} catch {
    Write-Host "  ✗ 检查Windows更新失败" -ForegroundColor Red
}
Write-Host ""

# 2. 检查Visual C++ Redistributable
Write-Host "[2/4] 检查Visual C++ Redistributable..." -ForegroundColor Yellow
$vcRedist = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64" -ErrorAction SilentlyContinue
if ($vcRedist) {
    Write-Host "  ✓ 已安装版本: $($vcRedist.Version)" -ForegroundColor Green
    Write-Host "  建议定期访问 https://aka.ms/vs/17/release/vc_redist.x64.exe 检查更新" -ForegroundColor Gray
} else {
    Write-Host "  ✗ 未安装Visual C++ Redistributable" -ForegroundColor Red
}
Write-Host ""

# 3. 检查浏览器版本
Write-Host "[3/4] 检查浏览器版本..." -ForegroundColor Yellow

# Chrome
$chromePath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe"
if (Test-Path $chromePath) {
    $chromeExe = (Get-ItemProperty $chromePath).'(default)'
    if (Test-Path $chromeExe) {
        $chromeVersion = (Get-Item $chromeExe).VersionInfo.FileVersion
        Write-Host "  Chrome: $chromeVersion" -ForegroundColor Gray
    }
}

# Edge
$edgePath = "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
if (Test-Path $edgePath) {
    $edgeVersion = (Get-Item $edgePath).VersionInfo.FileVersion
    Write-Host "  Edge: $edgeVersion" -ForegroundColor Gray
}

Write-Host "  建议: 保持浏览器自动更新开启" -ForegroundColor Yellow
Write-Host ""

# 4. 检查Windows Defender
Write-Host "[4/4] 检查Windows Defender..." -ForegroundColor Yellow
try {
    $defenderStatus = Get-MpComputerStatus
    
    Write-Host "  实时保护: $(if ($defenderStatus.RealTimeProtectionEnabled) { '已启用 ✓' } else { '未启用 ✗' })" -ForegroundColor $(if ($defenderStatus.RealTimeProtectionEnabled) { "Green" } else { "Red" })
    Write-Host "  病毒定义更新: $($defenderStatus.AntivirusSignatureLastUpdated)" -ForegroundColor Gray
    
    $daysSinceUpdate = ((Get-Date) - $defenderStatus.AntivirusSignatureLastUpdated).Days
    if ($daysSinceUpdate -gt 7) {
        Write-Host "  ⚠ 病毒定义已超过 $daysSinceUpdate 天未更新" -ForegroundColor Yellow
    } else {
        Write-Host "  ✓ 病毒定义更新及时" -ForegroundColor Green
    }
} catch {
    Write-Host "  ⚠ 无法获取Windows Defender状态" -ForegroundColor Yellow
}
Write-Host ""

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "更新检查完成" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
```

##### 3.2 应用程序更新

**版本检查和更新流程**：

```
应用程序更新流程:

1. 检查新版本
   ├─ 访问GitHub Releases页面
   ├─ 检查最新版本号
   └─ 比较当前版本

2. 下载新版本
   ├─ 下载发布包
   ├─ 验证文件完整性（可选：校验MD5/SHA256）
   └─ 解压到临时目录

3. 备份现有系统
   ├─ 停止服务
   ├─ 备份当前版本
   └─ 备份数据文件

4. 安装新版本
   ├─ 复制新文件到安装目录
   ├─ 更新配置文件（如有必要）
   └─ 数据迁移（如有必要）

5. 测试验证
   ├─ 启动服务
   ├─ 验证核心功能
   └─ 检查数据完整性

6. 回退准备
   ├─ 保留旧版本备份
   └─ 准备回退脚本
```

**更新脚本示例**：

```powershell
# 应用程序更新脚本: update_application.ps1

param(
    [Parameter(Mandatory=$true)]
    [string]$NewVersionZip,
    
    [switch]$SkipBackup = $false
)

$installDir = "C:\MealRecommendationSystem"
$backupDir = Join-Path $installDir "backup\pre_update_$(Get-Date -Format 'yyyyMMdd_HHmmss')"

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "应用程序更新工具" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""

# 步骤1: 验证新版本文件
Write-Host "[1/7] 验证新版本文件..." -ForegroundColor Yellow
if (-not (Test-Path $NewVersionZip)) {
    Write-Host "  ✗ 更新包不存在: $NewVersionZip" -ForegroundColor Red
    exit 1
}
Write-Host "  ✓ 更新包: $NewVersionZip" -ForegroundColor Green
Write-Host ""

# 步骤2: 停止服务
Write-Host "[2/7] 停止应用服务..." -ForegroundColor Yellow
$process = Get-Process -Name "MealRecommendationSystem" -ErrorAction SilentlyContinue
if ($process) {
    Stop-Process -Name "MealRecommendationSystem" -Force
    Start-Sleep -Seconds 3
    Write-Host "  ✓ 服务已停止" -ForegroundColor Green
} else {
    Write-Host "  ⚠ 服务未运行" -ForegroundColor Yellow
}
Write-Host ""

# 步骤3: 备份当前版本
if (-not $SkipBackup) {
    Write-Host "[3/7] 备份当前版本..." -ForegroundColor Yellow
    New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
    
    # 备份可执行文件和数据
    Copy-Item -Path "$installDir\bin" -Destination "$backupDir\bin" -Recurse -Force
    Copy-Item -Path "$installDir\data" -Destination "$backupDir\data" -Recurse -Force
    Copy-Item -Path "$installDir\www" -Destination "$backupDir\www" -Recurse -Force
    
    Write-Host "  ✓ 备份完成: $backupDir" -ForegroundColor Green
} else {
    Write-Host "[3/7] 跳过备份" -ForegroundColor Yellow
}
Write-Host ""

# 步骤4: 解压新版本
Write-Host "[4/7] 解压新版本..." -ForegroundColor Yellow
$tempDir = Join-Path $env:TEMP "MealRecommendation_Update"
if (Test-Path $tempDir) {
    Remove-Item -Path $tempDir -Recurse -Force
}
Expand-Archive -Path $NewVersionZip -DestinationPath $tempDir -Force
Write-Host "  ✓ 解压完成" -ForegroundColor Green
Write-Host ""

# 步骤5: 安装新版本
Write-Host "[5/7] 安装新版本..." -ForegroundColor Yellow
if (Test-Path "$tempDir\bin") {
    Copy-Item -Path "$tempDir\bin\*" -Destination "$installDir\bin\" -Force
    Write-Host "  ✓ 可执行文件已更新" -ForegroundColor Green
}
if (Test-Path "$tempDir\www") {
    Copy-Item -Path "$tempDir\www\*" -Destination "$installDir\www\" -Recurse -Force
    Write-Host "  ✓ Web文件已更新" -ForegroundColor Green
}
Write-Host ""

# 步骤6: 验证安装
Write-Host "[6/7] 验证安装..." -ForegroundColor Yellow
if (Test-Path "$installDir\bin\MealRecommendationSystem.exe") {
    $version = (Get-Item "$installDir\bin\MealRecommendationSystem.exe").VersionInfo
    Write-Host "  ✓ 新版本信息:" -ForegroundColor Green
    Write-Host "    文件版本: $($version.FileVersion)" -ForegroundColor Gray
    Write-Host "    产品版本: $($version.ProductVersion)" -ForegroundColor Gray
} else {
    Write-Host "  ✗ 可执行文件不存在" -ForegroundColor Red
    exit 1
}
Write-Host ""

# 步骤7: 启动服务
Write-Host "[7/7] 启动服务..." -ForegroundColor Yellow
Start-Process -FilePath "$installDir\bin\MealRecommendationSystem.exe" -WorkingDirectory "$installDir\bin"
Start-Sleep -Seconds 5

# 验证服务运行
$process = Get-Process -Name "MealRecommendationSystem" -ErrorAction SilentlyContinue
if ($process) {
    Write-Host "  ✓ 服务已启动" -ForegroundColor Green
    
    # 测试HTTP访问
    try {
        $response = Invoke-WebRequest -Uri "http://localhost:8000" -UseBasicParsing -TimeoutSec 10
        if ($response.StatusCode -eq 200) {
            Write-Host "  ✓ HTTP服务正常" -ForegroundColor Green
        }
    } catch {
        Write-Host "  ⚠ HTTP服务异常" -ForegroundColor Yellow
    }
} else {
    Write-Host "  ✗ 服务启动失败" -ForegroundColor Red
    Write-Host ""
    Write-Host "回退建议:" -ForegroundColor Yellow
    Write-Host "  1. 停止服务" -ForegroundColor Gray
    Write-Host "  2. 从备份恢复: $backupDir" -ForegroundColor Gray
    Write-Host "  3. 重新启动服务" -ForegroundColor Gray
    exit 1
}

Write-Host ""
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "更新完成！" -ForegroundColor Green
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "备份位置: $backupDir" -ForegroundColor Gray
Write-Host "如遇问题，可从备份恢复" -ForegroundColor Gray

# 清理临时文件
Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
```

**使用方法**：
```powershell
# 更新到新版本
.\update_application.ps1 -NewVersionZip "C:\Downloads\MealRecommendation_v2.0.zip"

# 更新但跳过备份（不推荐）
.\update_application.ps1 -NewVersionZip "C:\Downloads\MealRecommendation_v2.0.zip" -SkipBackup
```

---

由于内容较长，我将继续创建文档的其余部分...

### 6.1.2 定期维护

（继续编写...）

由于篇幅限制，我会创建完整的第6章和第7章文档。让我继续完成...
